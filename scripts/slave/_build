#!/usr/bin/env python3

import json
import subprocess
import multiprocessing
import sys
import os
from typing import Set, Dict 

CONFIG_DIR="/root/dev/config/dev"
BUILD_FILE=CONFIG_DIR + "/build.json"

class Task:
    label: str
    cmd: str

    def __init__(self, label: str, raw: dict):
        self.label = label
        if "packages" in raw:
            packages = raw["packages"]
            cmd = "dnf install -y " + " ".join(packages) 
        elif "shell" in raw:
            shell = raw["shell"]
            cmd = " && ".join(shell)
        else:
            raise Exception('task requires either packages or shell')
        self.cmd = cmd 

    def __str__(self):
        return self.label

class Node:
    dependencies: Set['Node']
    dependents: Set['Node']
    task: Task = None

    def __init__(self, task=None):
        self.task = task
        self.dependents = set()
        self.dependencies = set()

    def __str__(self):
        if not self.task:
            return 'root'
        return str(self.task)

    def __hash__(self):
        return hash(str(self))

    def __eq__(self, other: 'Node'):
        if isinstance(other, Node):
            return str(self) == str(other)
        return NotImplemented

def build_graph(meta: Dict):
    log("graph builder", "building dependency graph")
    nodes: Dict[str, Node] = {key: Node(Task(key, meta)) for key, meta in meta.items()}

    for key, task in meta.items():
        node = nodes[key]
        task_dependencies = set(task.get("depends_on", {})) 

        for task_dependency in task_dependencies:
            if task_dependency not in nodes:
                raise Exception(f"{task_dependency} doesn't exist")

            dependency_node = nodes[task_dependency]
            node.dependencies.add(dependency_node)
            dependency_node.dependents.add(node)

    root_node = Node()
    top_nodes = {node for node in nodes.values() if not node.dependencies}
    root_node.dependents = top_nodes
    return root_node

def print_graph(root: Node):
    nodes = set()
    queue = [root]

    while queue:
        node = queue.pop()
        if not node:
            continue

        nodes.add(node)
        queue.extend(list(node.dependents))

    for node in nodes:
        print(node)
        print(f'  dependencies: {",".join(map(str, node.dependencies))}')
        print(f'  dependents  : {",".join(map(str, node.dependents))}')

def log(role: str, msg: str):
    print(f"[{role}] {msg}")

def build(cfg_path: str):
    with open(cfg_path) as i:
        meta_raw = i.read()
    
    print("===================== build config =====================") 
    print(meta_raw)
    print("========================================================") 
  
    meta = json.loads(meta_raw)
    graph = build_graph(meta)
    print_graph(graph)
    task_queue: "Queue[Node]" = multiprocessing.Queue()
    done_queue: "Tuple[Queue[Node], int]" = multiprocessing.Queue() 

    def worker_fn(id: int):
        label = f"worker {i}"
        log(label, "ready")
        while True:
            node = task_queue.get()
            task = node.task
            label_with_task = f"{label} - {task}"
            log(label_with_task, "executing")

            try:
                with subprocess.Popen(
                        task.cmd,
                        shell=True,
                        stdout=subprocess.PIPE, 
                        stderr=subprocess.STDOUT, 
                        universal_newlines=True
                    ) as p:

                    for line in p.stdout:
                        log(label_with_task, line.strip())

            except Exception as e:
                done_queue.put((node, 1))
                return

            done_queue.put((node, 0))

    num_workers = os.cpu_count()
    done_nodes = set()
    waiting_nodes = set()
    total_tasks = len(meta) 

    def _log(msg: str):
        log("scheduler", msg)

    _log(f"initiated a pool of {num_workers} workers")
    workers = []
    for i in range(num_workers):
        worker = multiprocessing.Process(target=worker_fn, args=(i,))
        worker.start()
        workers.append(worker)

    for top_node in graph.dependents:
        task_queue.put(top_node)
    
    def run():
        while len(done_nodes) < total_tasks:
            (done_node, rc) = done_queue.get()
            if rc != 0:
                raise Exception(f"failed in executing {done_node}")

            done_nodes.add(done_node)
            _log(f"finished tasks: {', '.join(map(str, done_nodes))}")
            for dependent_node in done_node.dependents:
                waiting_nodes.add(dependent_node)

            to_remove = []
            for waiting_node in waiting_nodes:
                if waiting_node in done_nodes:
                    to_remove.append(waiting_node)
                    continue

                if any(dep not in done_nodes for dep in waiting_node.dependencies):
                    continue
                
                task_queue.put(waiting_node)
                _log(f"scheduled {waiting_node}")
                to_remove.append(waiting_node)

            for node in to_remove:
                waiting_nodes.remove(node)

            _log(f"waiting tasks: {', '.join(map(str, waiting_nodes))}")

    try:
        run()
    finally:
        for worker in workers:
            worker.terminate()
 
build(BUILD_FILE)
